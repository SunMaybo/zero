package install

var validate_067 = "syntax = \"proto2\";\npackage validate;\n\noption go_package = \"github.com/envoyproxy/protoc-gen-validate/validate\";\noption java_package = \"io.envoyproxy.pgv.validate\";\n\nimport \"google/protobuf/descriptor.proto\";\nimport \"google/protobuf/duration.proto\";\nimport \"google/protobuf/timestamp.proto\";\n\n// Validation rules applied at the message level\nextend google.protobuf.MessageOptions {\n    // Disabled nullifies any validation rules for this message, including any\n    // message fields associated with it that do support validation.\n    optional bool disabled = 1071;\n    // Ignore skips generation of validation methods for this message.\n    optional bool ignored = 1072;\n}\n\n// Validation rules applied at the oneof level\nextend google.protobuf.OneofOptions {\n    // Required ensures that exactly one the field options in a oneof is set;\n    // validation fails if no fields in the oneof are set.\n    optional bool required = 1071;\n}\n\n// Validation rules applied at the field level\nextend google.protobuf.FieldOptions {\n    // Rules specify the validations to be performed on this field. By default,\n    // no validation is performed against a field.\n    optional FieldRules rules = 1071;\n}\n\n// FieldRules encapsulates the rules for each type of field. Depending on the\n// field, the correct set should be used to ensure proper validations.\nmessage FieldRules {\n    optional MessageRules message = 17;\n    oneof type {\n        // Scalar Field Types\n        FloatRules    float    = 1;\n        DoubleRules   double   = 2;\n        Int32Rules    int32    = 3;\n        Int64Rules    int64    = 4;\n        UInt32Rules   uint32   = 5;\n        UInt64Rules   uint64   = 6;\n        SInt32Rules   sint32   = 7;\n        SInt64Rules   sint64   = 8;\n        Fixed32Rules  fixed32  = 9;\n        Fixed64Rules  fixed64  = 10;\n        SFixed32Rules sfixed32 = 11;\n        SFixed64Rules sfixed64 = 12;\n        BoolRules     bool     = 13;\n        StringRules   string   = 14;\n        BytesRules    bytes    = 15;\n\n        // Complex Field Types\n        EnumRules     enum     = 16;\n        RepeatedRules repeated = 18;\n        MapRules      map      = 19;\n\n        // Well-Known Field Types\n        AnyRules       any       = 20;\n        DurationRules  duration  = 21;\n        TimestampRules timestamp = 22;\n    }\n}\n\n// FloatRules describes the constraints applied to `float` values\nmessage FloatRules {\n    // Const specifies that this field must be exactly the specified value\n    optional float const = 1;\n\n    // Lt specifies that this field must be less than the specified value,\n    // exclusive\n    optional float lt = 2;\n\n    // Lte specifies that this field must be less than or equal to the\n    // specified value, inclusive\n    optional float lte = 3;\n\n    // Gt specifies that this field must be greater than the specified value,\n    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the\n    // range is reversed.\n    optional float gt = 4;\n\n    // Gte specifies that this field must be greater than or equal to the\n    // specified value, inclusive. If the value of Gte is larger than a\n    // specified Lt or Lte, the range is reversed.\n    optional float gte = 5;\n\n    // In specifies that this field must be equal to one of the specified\n    // values\n    repeated float in = 6;\n\n    // NotIn specifies that this field cannot be equal to one of the specified\n    // values\n    repeated float not_in = 7;\n\n    // IgnoreEmpty specifies that the validation rules of this field should be\n    // evaluated only if the field is not empty\n    optional bool ignore_empty = 8;\n}\n\n// DoubleRules describes the constraints applied to `double` values\nmessage DoubleRules {\n    // Const specifies that this field must be exactly the specified value\n    optional double const = 1;\n\n    // Lt specifies that this field must be less than the specified value,\n    // exclusive\n    optional double lt = 2;\n\n    // Lte specifies that this field must be less than or equal to the\n    // specified value, inclusive\n    optional double lte = 3;\n\n    // Gt specifies that this field must be greater than the specified value,\n    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the\n    // range is reversed.\n    optional double gt = 4;\n\n    // Gte specifies that this field must be greater than or equal to the\n    // specified value, inclusive. If the value of Gte is larger than a\n    // specified Lt or Lte, the range is reversed.\n    optional double gte = 5;\n\n    // In specifies that this field must be equal to one of the specified\n    // values\n    repeated double in = 6;\n\n    // NotIn specifies that this field cannot be equal to one of the specified\n    // values\n    repeated double not_in = 7;\n\n    // IgnoreEmpty specifies that the validation rules of this field should be\n    // evaluated only if the field is not empty\n    optional bool ignore_empty = 8;\n}\n\n// Int32Rules describes the constraints applied to `int32` values\nmessage Int32Rules {\n    // Const specifies that this field must be exactly the specified value\n    optional int32 const = 1;\n\n    // Lt specifies that this field must be less than the specified value,\n    // exclusive\n    optional int32 lt = 2;\n\n    // Lte specifies that this field must be less than or equal to the\n    // specified value, inclusive\n    optional int32 lte = 3;\n\n    // Gt specifies that this field must be greater than the specified value,\n    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the\n    // range is reversed.\n    optional int32 gt = 4;\n\n    // Gte specifies that this field must be greater than or equal to the\n    // specified value, inclusive. If the value of Gte is larger than a\n    // specified Lt or Lte, the range is reversed.\n    optional int32 gte = 5;\n\n    // In specifies that this field must be equal to one of the specified\n    // values\n    repeated int32 in = 6;\n\n    // NotIn specifies that this field cannot be equal to one of the specified\n    // values\n    repeated int32 not_in = 7;\n\n    // IgnoreEmpty specifies that the validation rules of this field should be\n    // evaluated only if the field is not empty\n    optional bool ignore_empty = 8;\n}\n\n// Int64Rules describes the constraints applied to `int64` values\nmessage Int64Rules {\n    // Const specifies that this field must be exactly the specified value\n    optional int64 const = 1;\n\n    // Lt specifies that this field must be less than the specified value,\n    // exclusive\n    optional int64 lt = 2;\n\n    // Lte specifies that this field must be less than or equal to the\n    // specified value, inclusive\n    optional int64 lte = 3;\n\n    // Gt specifies that this field must be greater than the specified value,\n    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the\n    // range is reversed.\n    optional int64 gt = 4;\n\n    // Gte specifies that this field must be greater than or equal to the\n    // specified value, inclusive. If the value of Gte is larger than a\n    // specified Lt or Lte, the range is reversed.\n    optional int64 gte = 5;\n\n    // In specifies that this field must be equal to one of the specified\n    // values\n    repeated int64 in = 6;\n\n    // NotIn specifies that this field cannot be equal to one of the specified\n    // values\n    repeated int64 not_in = 7;\n\n    // IgnoreEmpty specifies that the validation rules of this field should be\n    // evaluated only if the field is not empty\n    optional bool ignore_empty = 8;\n}\n\n// UInt32Rules describes the constraints applied to `uint32` values\nmessage UInt32Rules {\n    // Const specifies that this field must be exactly the specified value\n    optional uint32 const = 1;\n\n    // Lt specifies that this field must be less than the specified value,\n    // exclusive\n    optional uint32 lt = 2;\n\n    // Lte specifies that this field must be less than or equal to the\n    // specified value, inclusive\n    optional uint32 lte = 3;\n\n    // Gt specifies that this field must be greater than the specified value,\n    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the\n    // range is reversed.\n    optional uint32 gt = 4;\n\n    // Gte specifies that this field must be greater than or equal to the\n    // specified value, inclusive. If the value of Gte is larger than a\n    // specified Lt or Lte, the range is reversed.\n    optional uint32 gte = 5;\n\n    // In specifies that this field must be equal to one of the specified\n    // values\n    repeated uint32 in = 6;\n\n    // NotIn specifies that this field cannot be equal to one of the specified\n    // values\n    repeated uint32 not_in = 7;\n\n    // IgnoreEmpty specifies that the validation rules of this field should be\n    // evaluated only if the field is not empty\n    optional bool ignore_empty = 8;\n}\n\n// UInt64Rules describes the constraints applied to `uint64` values\nmessage UInt64Rules {\n    // Const specifies that this field must be exactly the specified value\n    optional uint64 const = 1;\n\n    // Lt specifies that this field must be less than the specified value,\n    // exclusive\n    optional uint64 lt = 2;\n\n    // Lte specifies that this field must be less than or equal to the\n    // specified value, inclusive\n    optional uint64 lte = 3;\n\n    // Gt specifies that this field must be greater than the specified value,\n    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the\n    // range is reversed.\n    optional uint64 gt = 4;\n\n    // Gte specifies that this field must be greater than or equal to the\n    // specified value, inclusive. If the value of Gte is larger than a\n    // specified Lt or Lte, the range is reversed.\n    optional uint64 gte = 5;\n\n    // In specifies that this field must be equal to one of the specified\n    // values\n    repeated uint64 in = 6;\n\n    // NotIn specifies that this field cannot be equal to one of the specified\n    // values\n    repeated uint64 not_in = 7;\n\n    // IgnoreEmpty specifies that the validation rules of this field should be\n    // evaluated only if the field is not empty\n    optional bool ignore_empty = 8;\n}\n\n// SInt32Rules describes the constraints applied to `sint32` values\nmessage SInt32Rules {\n    // Const specifies that this field must be exactly the specified value\n    optional sint32 const = 1;\n\n    // Lt specifies that this field must be less than the specified value,\n    // exclusive\n    optional sint32 lt = 2;\n\n    // Lte specifies that this field must be less than or equal to the\n    // specified value, inclusive\n    optional sint32 lte = 3;\n\n    // Gt specifies that this field must be greater than the specified value,\n    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the\n    // range is reversed.\n    optional sint32 gt = 4;\n\n    // Gte specifies that this field must be greater than or equal to the\n    // specified value, inclusive. If the value of Gte is larger than a\n    // specified Lt or Lte, the range is reversed.\n    optional sint32 gte = 5;\n\n    // In specifies that this field must be equal to one of the specified\n    // values\n    repeated sint32 in = 6;\n\n    // NotIn specifies that this field cannot be equal to one of the specified\n    // values\n    repeated sint32 not_in = 7;\n\n    // IgnoreEmpty specifies that the validation rules of this field should be\n    // evaluated only if the field is not empty\n    optional bool ignore_empty = 8;\n}\n\n// SInt64Rules describes the constraints applied to `sint64` values\nmessage SInt64Rules {\n    // Const specifies that this field must be exactly the specified value\n    optional sint64 const = 1;\n\n    // Lt specifies that this field must be less than the specified value,\n    // exclusive\n    optional sint64 lt = 2;\n\n    // Lte specifies that this field must be less than or equal to the\n    // specified value, inclusive\n    optional sint64 lte = 3;\n\n    // Gt specifies that this field must be greater than the specified value,\n    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the\n    // range is reversed.\n    optional sint64 gt = 4;\n\n    // Gte specifies that this field must be greater than or equal to the\n    // specified value, inclusive. If the value of Gte is larger than a\n    // specified Lt or Lte, the range is reversed.\n    optional sint64 gte = 5;\n\n    // In specifies that this field must be equal to one of the specified\n    // values\n    repeated sint64 in = 6;\n\n    // NotIn specifies that this field cannot be equal to one of the specified\n    // values\n    repeated sint64 not_in = 7;\n\n    // IgnoreEmpty specifies that the validation rules of this field should be\n    // evaluated only if the field is not empty\n    optional bool ignore_empty = 8;\n}\n\n// Fixed32Rules describes the constraints applied to `fixed32` values\nmessage Fixed32Rules {\n    // Const specifies that this field must be exactly the specified value\n    optional fixed32 const = 1;\n\n    // Lt specifies that this field must be less than the specified value,\n    // exclusive\n    optional fixed32 lt = 2;\n\n    // Lte specifies that this field must be less than or equal to the\n    // specified value, inclusive\n    optional fixed32 lte = 3;\n\n    // Gt specifies that this field must be greater than the specified value,\n    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the\n    // range is reversed.\n    optional fixed32 gt = 4;\n\n    // Gte specifies that this field must be greater than or equal to the\n    // specified value, inclusive. If the value of Gte is larger than a\n    // specified Lt or Lte, the range is reversed.\n    optional fixed32 gte = 5;\n\n    // In specifies that this field must be equal to one of the specified\n    // values\n    repeated fixed32 in = 6;\n\n    // NotIn specifies that this field cannot be equal to one of the specified\n    // values\n    repeated fixed32 not_in = 7;\n\n    // IgnoreEmpty specifies that the validation rules of this field should be\n    // evaluated only if the field is not empty\n    optional bool ignore_empty = 8;\n}\n\n// Fixed64Rules describes the constraints applied to `fixed64` values\nmessage Fixed64Rules {\n    // Const specifies that this field must be exactly the specified value\n    optional fixed64 const = 1;\n\n    // Lt specifies that this field must be less than the specified value,\n    // exclusive\n    optional fixed64 lt = 2;\n\n    // Lte specifies that this field must be less than or equal to the\n    // specified value, inclusive\n    optional fixed64 lte = 3;\n\n    // Gt specifies that this field must be greater than the specified value,\n    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the\n    // range is reversed.\n    optional fixed64 gt = 4;\n\n    // Gte specifies that this field must be greater than or equal to the\n    // specified value, inclusive. If the value of Gte is larger than a\n    // specified Lt or Lte, the range is reversed.\n    optional fixed64 gte = 5;\n\n    // In specifies that this field must be equal to one of the specified\n    // values\n    repeated fixed64 in = 6;\n\n    // NotIn specifies that this field cannot be equal to one of the specified\n    // values\n    repeated fixed64 not_in = 7;\n\n    // IgnoreEmpty specifies that the validation rules of this field should be\n    // evaluated only if the field is not empty\n    optional bool ignore_empty = 8;\n}\n\n// SFixed32Rules describes the constraints applied to `sfixed32` values\nmessage SFixed32Rules {\n    // Const specifies that this field must be exactly the specified value\n    optional sfixed32 const = 1;\n\n    // Lt specifies that this field must be less than the specified value,\n    // exclusive\n    optional sfixed32 lt = 2;\n\n    // Lte specifies that this field must be less than or equal to the\n    // specified value, inclusive\n    optional sfixed32 lte = 3;\n\n    // Gt specifies that this field must be greater than the specified value,\n    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the\n    // range is reversed.\n    optional sfixed32 gt = 4;\n\n    // Gte specifies that this field must be greater than or equal to the\n    // specified value, inclusive. If the value of Gte is larger than a\n    // specified Lt or Lte, the range is reversed.\n    optional sfixed32 gte = 5;\n\n    // In specifies that this field must be equal to one of the specified\n    // values\n    repeated sfixed32 in = 6;\n\n    // NotIn specifies that this field cannot be equal to one of the specified\n    // values\n    repeated sfixed32 not_in = 7;\n\n    // IgnoreEmpty specifies that the validation rules of this field should be\n    // evaluated only if the field is not empty\n    optional bool ignore_empty = 8;\n}\n\n// SFixed64Rules describes the constraints applied to `sfixed64` values\nmessage SFixed64Rules {\n    // Const specifies that this field must be exactly the specified value\n    optional sfixed64 const = 1;\n\n    // Lt specifies that this field must be less than the specified value,\n    // exclusive\n    optional sfixed64 lt = 2;\n\n    // Lte specifies that this field must be less than or equal to the\n    // specified value, inclusive\n    optional sfixed64 lte = 3;\n\n    // Gt specifies that this field must be greater than the specified value,\n    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the\n    // range is reversed.\n    optional sfixed64 gt = 4;\n\n    // Gte specifies that this field must be greater than or equal to the\n    // specified value, inclusive. If the value of Gte is larger than a\n    // specified Lt or Lte, the range is reversed.\n    optional sfixed64 gte = 5;\n\n    // In specifies that this field must be equal to one of the specified\n    // values\n    repeated sfixed64 in = 6;\n\n    // NotIn specifies that this field cannot be equal to one of the specified\n    // values\n    repeated sfixed64 not_in = 7;\n\n    // IgnoreEmpty specifies that the validation rules of this field should be\n    // evaluated only if the field is not empty\n    optional bool ignore_empty = 8;\n}\n\n// BoolRules describes the constraints applied to `bool` values\nmessage BoolRules {\n    // Const specifies that this field must be exactly the specified value\n    optional bool const = 1;\n}\n\n// StringRules describe the constraints applied to `string` values\nmessage StringRules {\n    // Const specifies that this field must be exactly the specified value\n    optional string const = 1;\n\n    // Len specifies that this field must be the specified number of\n    // characters (Unicode code points). Note that the number of\n    // characters may differ from the number of bytes in the string.\n    optional uint64 len = 19;\n\n    // MinLen specifies that this field must be the specified number of\n    // characters (Unicode code points) at a minimum. Note that the number of\n    // characters may differ from the number of bytes in the string.\n    optional uint64 min_len = 2;\n\n    // MaxLen specifies that this field must be the specified number of\n    // characters (Unicode code points) at a maximum. Note that the number of\n    // characters may differ from the number of bytes in the string.\n    optional uint64 max_len = 3;\n\n    // LenBytes specifies that this field must be the specified number of bytes\n    optional uint64 len_bytes = 20;\n\n    // MinBytes specifies that this field must be the specified number of bytes\n    // at a minimum\n    optional uint64 min_bytes = 4;\n\n    // MaxBytes specifies that this field must be the specified number of bytes\n    // at a maximum\n    optional uint64 max_bytes = 5;\n\n    // Pattern specifes that this field must match against the specified\n    // regular expression (RE2 syntax). The included expression should elide\n    // any delimiters.\n    optional string pattern  = 6;\n\n    // Prefix specifies that this field must have the specified substring at\n    // the beginning of the string.\n    optional string prefix   = 7;\n\n    // Suffix specifies that this field must have the specified substring at\n    // the end of the string.\n    optional string suffix   = 8;\n\n    // Contains specifies that this field must have the specified substring\n    // anywhere in the string.\n    optional string contains = 9;\n\n    // NotContains specifies that this field cannot have the specified substring\n    // anywhere in the string.\n    optional string not_contains = 23;\n\n    // In specifies that this field must be equal to one of the specified\n    // values\n    repeated string in     = 10;\n\n    // NotIn specifies that this field cannot be equal to one of the specified\n    // values\n    repeated string not_in = 11;\n\n    // WellKnown rules provide advanced constraints against common string\n    // patterns\n    oneof well_known {\n        // Email specifies that the field must be a valid email address as\n        // defined by RFC 5322\n        bool email    = 12;\n\n        // Hostname specifies that the field must be a valid hostname as\n        // defined by RFC 1034. This constraint does not support\n        // internationalized domain names (IDNs).\n        bool hostname = 13;\n\n        // Ip specifies that the field must be a valid IP (v4 or v6) address.\n        // Valid IPv6 addresses should not include surrounding square brackets.\n        bool ip       = 14;\n\n        // Ipv4 specifies that the field must be a valid IPv4 address.\n        bool ipv4     = 15;\n\n        // Ipv6 specifies that the field must be a valid IPv6 address. Valid\n        // IPv6 addresses should not include surrounding square brackets.\n        bool ipv6     = 16;\n\n        // Uri specifies that the field must be a valid, absolute URI as defined\n        // by RFC 3986\n        bool uri      = 17;\n\n        // UriRef specifies that the field must be a valid URI as defined by RFC\n        // 3986 and may be relative or absolute.\n        bool uri_ref  = 18;\n\n        // Address specifies that the field must be either a valid hostname as\n        // defined by RFC 1034 (which does not support internationalized domain\n        // names or IDNs), or it can be a valid IP (v4 or v6).\n        bool address  = 21;\n\n        // Uuid specifies that the field must be a valid UUID as defined by\n        // RFC 4122\n        bool uuid     = 22;\n\n        // WellKnownRegex specifies a common well known pattern defined as a regex.\n        KnownRegex well_known_regex = 24;\n    }\n\n  // This applies to regexes HTTP_HEADER_NAME and HTTP_HEADER_VALUE to enable\n  // strict header validation.\n  // By default, this is true, and HTTP header validations are RFC-compliant.\n  // Setting to false will enable a looser validations that only disallows\n  // \\r\\n\\0 characters, which can be used to bypass header matching rules.\n  optional bool strict = 25 [default = true];\n\n  // IgnoreEmpty specifies that the validation rules of this field should be\n  // evaluated only if the field is not empty\n  optional bool ignore_empty = 26;\n}\n\n// WellKnownRegex contain some well-known patterns.\nenum KnownRegex {\n  UNKNOWN = 0;\n\n  // HTTP header name as defined by RFC 7230.\n  HTTP_HEADER_NAME = 1;\n\n  // HTTP header value as defined by RFC 7230.\n  HTTP_HEADER_VALUE = 2;\n}\n\n// BytesRules describe the constraints applied to `bytes` values\nmessage BytesRules {\n    // Const specifies that this field must be exactly the specified value\n    optional bytes const = 1;\n\n    // Len specifies that this field must be the specified number of bytes\n    optional uint64 len = 13;\n\n    // MinLen specifies that this field must be the specified number of bytes\n    // at a minimum\n    optional uint64 min_len = 2;\n\n    // MaxLen specifies that this field must be the specified number of bytes\n    // at a maximum\n    optional uint64 max_len = 3;\n\n    // Pattern specifes that this field must match against the specified\n    // regular expression (RE2 syntax). The included expression should elide\n    // any delimiters.\n    optional string pattern  = 4;\n\n    // Prefix specifies that this field must have the specified bytes at the\n    // beginning of the string.\n    optional bytes  prefix   = 5;\n\n    // Suffix specifies that this field must have the specified bytes at the\n    // end of the string.\n    optional bytes  suffix   = 6;\n\n    // Contains specifies that this field must have the specified bytes\n    // anywhere in the string.\n    optional bytes  contains = 7;\n\n    // In specifies that this field must be equal to one of the specified\n    // values\n    repeated bytes in     = 8;\n\n    // NotIn specifies that this field cannot be equal to one of the specified\n    // values\n    repeated bytes not_in = 9;\n\n    // WellKnown rules provide advanced constraints against common byte\n    // patterns\n    oneof well_known {\n        // Ip specifies that the field must be a valid IP (v4 or v6) address in\n        // byte format\n        bool ip   = 10;\n\n        // Ipv4 specifies that the field must be a valid IPv4 address in byte\n        // format\n        bool ipv4 = 11;\n\n        // Ipv6 specifies that the field must be a valid IPv6 address in byte\n        // format\n        bool ipv6 = 12;\n    }\n\n    // IgnoreEmpty specifies that the validation rules of this field should be\n    // evaluated only if the field is not empty\n    optional bool ignore_empty = 14;\n}\n\n// EnumRules describe the constraints applied to enum values\nmessage EnumRules {\n    // Const specifies that this field must be exactly the specified value\n    optional int32 const        = 1;\n\n    // DefinedOnly specifies that this field must be only one of the defined\n    // values for this enum, failing on any undefined value.\n    optional bool  defined_only = 2;\n\n    // In specifies that this field must be equal to one of the specified\n    // values\n    repeated int32 in           = 3;\n\n    // NotIn specifies that this field cannot be equal to one of the specified\n    // values\n    repeated int32 not_in       = 4;\n}\n\n// MessageRules describe the constraints applied to embedded message values.\n// For message-type fields, validation is performed recursively.\nmessage MessageRules {\n    // Skip specifies that the validation rules of this field should not be\n    // evaluated\n    optional bool skip     = 1;\n\n    // Required specifies that this field must be set\n    optional bool required = 2;\n}\n\n// RepeatedRules describe the constraints applied to `repeated` values\nmessage RepeatedRules {\n    // MinItems specifies that this field must have the specified number of\n    // items at a minimum\n    optional uint64 min_items = 1;\n\n    // MaxItems specifies that this field must have the specified number of\n    // items at a maximum\n    optional uint64 max_items = 2;\n\n    // Unique specifies that all elements in this field must be unique. This\n    // contraint is only applicable to scalar and enum types (messages are not\n    // supported).\n    optional bool   unique    = 3;\n\n    // Items specifies the contraints to be applied to each item in the field.\n    // Repeated message fields will still execute validation against each item\n    // unless skip is specified here.\n    optional FieldRules items = 4;\n\n    // IgnoreEmpty specifies that the validation rules of this field should be\n    // evaluated only if the field is not empty\n    optional bool ignore_empty = 5;\n}\n\n// MapRules describe the constraints applied to `map` values\nmessage MapRules {\n    // MinPairs specifies that this field must have the specified number of\n    // KVs at a minimum\n    optional uint64 min_pairs = 1;\n\n    // MaxPairs specifies that this field must have the specified number of\n    // KVs at a maximum\n    optional uint64 max_pairs = 2;\n\n    // NoSparse specifies values in this field cannot be unset. This only\n    // applies to map's with message value types.\n    optional bool no_sparse = 3;\n\n    // Keys specifies the constraints to be applied to each key in the field.\n    optional FieldRules keys   = 4;\n\n    // Values specifies the constraints to be applied to the value of each key\n    // in the field. Message values will still have their validations evaluated\n    // unless skip is specified here.\n    optional FieldRules values = 5;\n\n    // IgnoreEmpty specifies that the validation rules of this field should be\n    // evaluated only if the field is not empty\n    optional bool ignore_empty = 6;\n}\n\n// AnyRules describe constraints applied exclusively to the\n// `google.protobuf.Any` well-known type\nmessage AnyRules {\n    // Required specifies that this field must be set\n    optional bool required = 1;\n\n    // In specifies that this field's `type_url` must be equal to one of the\n    // specified values.\n    repeated string in     = 2;\n\n    // NotIn specifies that this field's `type_url` must not be equal to any of\n    // the specified values.\n    repeated string not_in = 3;\n}\n\n// DurationRules describe the constraints applied exclusively to the\n// `google.protobuf.Duration` well-known type\nmessage DurationRules {\n    // Required specifies that this field must be set\n    optional bool required = 1;\n\n    // Const specifies that this field must be exactly the specified value\n    optional google.protobuf.Duration const = 2;\n\n    // Lt specifies that this field must be less than the specified value,\n    // exclusive\n    optional google.protobuf.Duration lt = 3;\n\n    // Lt specifies that this field must be less than the specified value,\n    // inclusive\n    optional google.protobuf.Duration lte = 4;\n\n    // Gt specifies that this field must be greater than the specified value,\n    // exclusive\n    optional google.protobuf.Duration gt = 5;\n\n    // Gte specifies that this field must be greater than the specified value,\n    // inclusive\n    optional google.protobuf.Duration gte = 6;\n\n    // In specifies that this field must be equal to one of the specified\n    // values\n    repeated google.protobuf.Duration in = 7;\n\n    // NotIn specifies that this field cannot be equal to one of the specified\n    // values\n    repeated google.protobuf.Duration not_in = 8;\n}\n\n// TimestampRules describe the constraints applied exclusively to the\n// `google.protobuf.Timestamp` well-known type\nmessage TimestampRules {\n    // Required specifies that this field must be set\n    optional bool required = 1;\n\n    // Const specifies that this field must be exactly the specified value\n    optional google.protobuf.Timestamp const = 2;\n\n    // Lt specifies that this field must be less than the specified value,\n    // exclusive\n    optional google.protobuf.Timestamp lt = 3;\n\n    // Lte specifies that this field must be less than the specified value,\n    // inclusive\n    optional google.protobuf.Timestamp lte = 4;\n\n    // Gt specifies that this field must be greater than the specified value,\n    // exclusive\n    optional google.protobuf.Timestamp gt = 5;\n\n    // Gte specifies that this field must be greater than the specified value,\n    // inclusive\n    optional google.protobuf.Timestamp gte = 6;\n\n    // LtNow specifies that this must be less than the current time. LtNow\n    // can only be used with the Within rule.\n    optional bool lt_now  = 7;\n\n    // GtNow specifies that this must be greater than the current time. GtNow\n    // can only be used with the Within rule.\n    optional bool gt_now  = 8;\n\n    // Within specifies that this field must be within this duration of the\n    // current time. This constraint can be used alone or with the LtNow and\n    // GtNow rules.\n    optional google.protobuf.Duration within = 9;\n}\n"
var xbb_067 = "syntax = \"proto3\";\npackage xbb;\n\noption java_package = \"cn.xunhou.grpc.proto.xbb\";\n\nimport \"google/protobuf/descriptor.proto\";\n\nimport \"validate/validate.proto\";\n\n\n//薪班班枚举名字定义\nextend google.protobuf.EnumValueOptions{\n  string name_enum = 2000;\n}\n\n\n//薪班班雪花ID对应通用请求声明\nmessage XbbSnowIdBeRequest{\n  sfixed64 id = 1 [(validate.rules).sfixed64.gt = 0];\n}\nmessage XbbSnowIdBeResponse{\n  sfixed64  id = 1;\n}\n//薪班班ID对应通用请求声明\nmessage XbbIdBeRequest{\n  int32 id = 1 [(validate.rules).int32.gt = 0];\n}\nmessage XbbIdBeResponse{\n  int32  id = 1;\n}\n\nenum XbbEnable{\n  XBB_ENABLED = 0;\n  XBB_DISABLE = 1;\n}\n\nenum XbbDeleted{\n  XBB_UN_DELETED = 0;\n  XBB_DELETED = 1;\n}\n\n"
